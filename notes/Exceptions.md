# Exceptions in Haskell

The Haskell 98 and 2010 standards provide a limited form of exceptions in the IO monad. The IO
exception mechanism has been extended by the `Control.Exception` module that comes with GHC to
include exceptions generated by purely functional code, and to define an extensible hierachy of
exception types. Everything is done with library functions (higher level exception handling
combinators that embody more powerful abstractions).

```haskell
throw :: Exception e => e -> a

class (Typeable e, Show e) => Exception e where
    ...

newtype ErrorCall = ErrorCall String
                  deriving Typeable

instance Show ErrorCall where { ... }
instance Exception ErrorCall

error :: String -> a
error s = throw (ErrorCall s)
```

I/O operations in Haskell also throw excpeitons to indicate errors, and these are usablly values
of the `IOException` type. Operations to build and insepct `IOException` can be found in the
`System.IO.Error` library

Exceptions can be caught in Haskell, but __only in the IO monad__.

```haskell
catch :: Exception e => IO a -> (e -> IO a) -> IO a
```

The second argument to `catch` is the exception handler. `Catch` catches only exceptions of a
particular type, determined bu the argument of the exception handler. Note you only want to catch
all exceptions for debugging and can use `SomeException` for the type of e in `catch`.

```haskell
data MyException = MyException deriving (Show, Typeable)
instance Exception MyException

> throw MyException
*** Esxception: MyException
-- For testing/debugging
> throw (ErrorCall "oops") `catch` \e -> print (e :: SomeException)
-- | Variant of catch with Either inside the IO result
try :: Exception e => IO a -> IO (Either e a)
-- | Arguments switch from catch when the handler is short and the action long
handle :: (e -> IO a) -> IO a -> IO a
-- | Perform some operation when the exception is thrown
onException :: IO a -> IO b -> IO a
onException io what = io `catch` e -> do _ <- what; throwIO (e :: SomeException)
-- | Throw in the IO Monad
throwIO :: Exception e => e -> IO a
```

__Note use always throwIO in the IO Monad since throwIO guarantees strict ordering with respect to
the other IO operations, whereas throw does not__.

```haskell
-- | Does not have safety in presence of thread cancellation (fix via 09)
bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
bracket before after during = do
    a <- before
    c <- during a `onException` after a
    after a
    return c

bracket (newTempFile "temp")
        (\file -> removeFile file)
        (\file -> ...)
```

The bracket function allows us to set up an exception handler to reliably deallocate a resource or
perform some cleanup operation.

```haskell
finally :: IO a -> IO b -> IO a
finally io after = do
    io `onException` after
    io
```
